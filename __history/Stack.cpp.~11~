#pragma hdrstop

#include "Stack.h"

Stack* InStack(Stack *top, char data)
{
	Stack *item = new Stack;
	item->data = data;
	item->next = top;
	return item;
}

Stack* OutStack(Stack *top, char *data)
{
	Stack *item = top;
	*data = top->data;
	top = top->next;
	delete item;
	return top;
}

int OPZ :: Priority (char symbol)
{
	switch(symbol)
	{
		case '*':
		case '/': return 3;
		case '+':
		case '-': return 2;
		case '(': return 1;
	}
	return 0;
}

void OPZ :: IntoOPZ(TEdit *Edit1, TEdit *Edit2)
{
	top = NULL;
	String inputStr, outputStr;  //строка с инфиксной и постфиксной формами
	outputStr = "";
	char inSymb, outSymb;   //символы строки с инфиксной и постфиксной формами
	inputStr = Edit1->Text;
//	znak<<'*'<<'/'<<'+'<<'-';
	int length = inputStr.Length();
	for (int i = 1; i <= length; i++)
	{
		inSymb = inputStr[i];
		if (inSymb == '(')                //если символ входной строки (
			top = InStack(top, inSymb);   //записать его в стек
		if (inSymb == ')')                //если символ входной строки )
		{
			while (top->data != '(')      //пока в стеке не дошли до (
			{
				top = OutStack(top, &outSymb);  //доставать символы из стека
				outputStr += outSymb;           //и записывать их в выходную строку
			}
			top = OutStack(top, &outSymb);      //достать из стека ( в никуда
		}
		if (inSymb >= 'a' && inSymb <= 'z')    //если символ входной строки буква
			outputStr += inSymb;               //записать его в выходную строку
		for (int x=1; x<=4; x++)
		{
			if (/*inSymb ==*/ znak[x])
			{
//				while (top != NULL && Priority(top->data) >= Priority(inSymb))
//				{
//					top = OutStack(top, &outSymb);  //достать последний символ стека
//					outputStr += outSymb;           //в выходную строку
//				}
//				top = InStack(top, inSymb);         //в стек записать текущий символ
			}
		}
/////////////////////
//		if (znak.Contains(inSymb))             //если символ входной строки знак
//		{
//			while (top != NULL && Priority(top->data) >= Priority(inSymb))
//			{
//				top = OutStack(top, &outSymb);  //достать последний символ стека
//				outputStr += outSymb;           //в выходную строку
//			}
//			top = InStack(top, inSymb);         //в стек записать текущий символ
//		}
	}
	while (top != NULL)			//когда символы закончились доставать
	{                           // в выходную строку все, что осталось
		top = OutStack(top, &outSymb);
		outputStr += outSymb;
	}
	Edit2->Text = outputStr;
}

double OPZ :: Rezult(String outputStr)
{
	char variable, variable1, variable2;   //для имен переменных
	//для значений переменных и результата действия над ними
	double value1, value2, rez;
//	znak << '*' << '/' << '+' << '-';
	char valueRez = 'z' + 1;   //имя "новой переменной" после совершения операции
	for (int i = 1; i < 6; i++)
	{
		variable = outputStr[i];
//		if (!znak.Contains(variable))       //записывать в стек переменные
//			top = InStack(top, variable);
//		else
		{                                      //если символ - знак
			top = OutStack(top, &variable1);   //взять 2 переменные из стека
			top = OutStack(top, &variable2);
			value1 = array[int(variable1)];    //найти их значения в массиве
			value2 = array[int(variable2)];
			switch(variable)
			{
				case '+': rez = variable2 + variable1; break;
				case '-': rez = variable2 - variable1; break;
				case '*': rez = variable2 * variable1; break;
				case '/': rez = variable2 / variable1; break;
			}
			//запись результата действия в общий массив значений переменных
			array[int(valueRez)] = rez;
			//запись "новой переменной"(результат действия над старыми) в стек
			top = InStack(top, valueRez);
			//чтобы при записи в общий массив не перекрыть другие переменные
			valueRez++;
		}
	}
	return rez;
}

#pragma package(smart_init)
